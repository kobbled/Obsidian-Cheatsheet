/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImageCaptions
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var ImageCaptions = class extends import_obsidian.Plugin {
  async onload() {
    this.registerMarkdownPostProcessor(externalImageProcessor());
    this.observer = new MutationObserver((mutations) => {
      mutations.forEach((rec) => {
        if (rec.type === "childList") {
          rec.target.querySelectorAll(".image-embed").forEach((imageEmbedContainer) => {
            var _a;
            const img = imageEmbedContainer.querySelector("img");
            let captionText = imageEmbedContainer.getAttribute("alt") || "";
            const width = imageEmbedContainer.getAttribute("width") || "";
            if (captionText === imageEmbedContainer.getAttribute("src")) {
              captionText = "";
            }
            if (!img)
              return;
            const figure = imageEmbedContainer.querySelector("figure");
            const figCaption = imageEmbedContainer.querySelector("figcaption");
            if (figure || ((_a = img.parentElement) == null ? void 0 : _a.nodeName) === "FIGURE") {
              if (figCaption && captionText) {
                figCaption.innerText = captionText;
              } else if (!captionText) {
                imageEmbedContainer.appendChild(img);
                figure == null ? void 0 : figure.remove();
              }
            } else {
              if (captionText && captionText !== imageEmbedContainer.getAttribute("src")) {
                insertFigureWithCaption(img, imageEmbedContainer, captionText);
              }
            }
            if (width) {
              img.setAttribute("width", width);
            } else {
              img.removeAttribute("width");
            }
          });
        }
      });
    });
    this.observer.observe(document.body, { subtree: true, childList: true });
  }
  onunload() {
    this.observer.disconnect();
  }
};
function externalImageProcessor() {
  return (el) => {
    el.findAll("img:not(.emoji)").forEach((img) => {
      const captionText = img.getAttribute("alt");
      const parent = img.parentElement;
      if (parent && (parent == null ? void 0 : parent.nodeName) !== "FIGURE" && captionText && captionText !== img.getAttribute("src")) {
        insertFigureWithCaption(img, parent, captionText);
      }
    });
  };
}
function insertFigureWithCaption(imageEl, outerEl, captionText) {
  const figure = outerEl.createEl("figure");
  figure.addClass("image-captions-figure");
  figure.appendChild(imageEl);
  figure.createEl("figcaption", {
    text: captionText,
    cls: "image-captions-caption"
  });
}
